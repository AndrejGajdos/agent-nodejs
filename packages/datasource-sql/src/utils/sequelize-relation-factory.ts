import { Model } from 'sequelize/types/model';
import { ModelStatic, Sequelize } from 'sequelize';

import { ForeignKeyReference } from './types';

export default class SequelizeRelationFactory {
  static build(
    tableName: string,
    foreignReferences: Partial<ForeignKeyReference>[],
    uniqueFields: string[],
    sequelize: Sequelize,
  ): void {
    const model = sequelize.model(tableName);

    if (SequelizeRelationFactory.isJunctionTable(model)) {
      SequelizeRelationFactory.buildForJunctionTable(
        foreignReferences as [Partial<ForeignKeyReference>, Partial<ForeignKeyReference>],
        model,
        sequelize,
      );
    } else {
      SequelizeRelationFactory.buildOtherRelations(
        foreignReferences,
        model,
        uniqueFields,
        sequelize,
      );
    }
  }

  private static buildOtherRelations(
    foreignReferences: Partial<ForeignKeyReference>[],
    model: ModelStatic<Model>,
    uniqueFields: string[],
    sequelize: Sequelize,
  ): void {
    foreignReferences.forEach(
      ({ columnName: foreignKey, referencedTableName, referencedColumnName: sourceKey }) => {
        const referencedModel = sequelize.model(referencedTableName);

        model.belongsTo(referencedModel, { foreignKey, targetKey: sourceKey });

        if (uniqueFields.includes(foreignKey)) {
          referencedModel.hasOne(model, { foreignKey, sourceKey });
        } else {
          referencedModel.hasMany(model, { foreignKey, sourceKey });
        }
      },
    );
  }

  private static buildForJunctionTable(
    foreignReferences: [Partial<ForeignKeyReference>, Partial<ForeignKeyReference>],
    model: ModelStatic<Model>,
    sequelize: Sequelize,
  ): void {
    const [
      { referencedTableName: tableA, columnName: columnA, referencedColumnName: referencedColumnA },
      { referencedTableName: tableB, columnName: columnB, referencedColumnName: referencedColumnB },
    ] = foreignReferences;

    const modelA = sequelize.model(tableA);
    const modelB = sequelize.model(tableB);
    const through = model.name;

    modelA.belongsToMany(modelB, { through, foreignKey: columnA, otherKey: columnB });
    modelB.belongsToMany(modelA, { through, foreignKey: columnB, otherKey: columnA });
    model.belongsTo(modelA, { foreignKey: columnA, targetKey: referencedColumnA });
    model.belongsTo(modelB, { foreignKey: columnB, targetKey: referencedColumnB });
  }

  private static isJunctionTable(model: ModelStatic<Model>): boolean {
    const modelAttributes = model.getAttributes();
    // remove autogenerated field to keep the belongsToMany behavior
    const attributes = Object.values(modelAttributes);
    const modelAttributesDefinition = attributes.filter(({ _autoGenerated }) => !_autoGenerated);
    if (modelAttributesDefinition.length !== 2) return false;

    return !modelAttributesDefinition.some(({ primaryKey }) => !primaryKey);
  }
}
