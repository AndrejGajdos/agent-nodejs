import { Model } from 'sequelize/types/model';
import { ModelStatic, Sequelize } from 'sequelize';

import { ForeignKeyReference } from './types';

export default class RelationFactory {
  static build(
    tableName: string,
    foreignReferences: Partial<ForeignKeyReference>[],
    excludedTables: string[],
    uniqueFields: string[],
    sequelize: Sequelize,
  ): void {
    if (excludedTables.includes(tableName)) {
      return;
    }

    const model = sequelize.model(tableName);

    if (RelationFactory.isJunctionTable(model)) {
      RelationFactory.buildForJunctionTable(
        foreignReferences as [Partial<ForeignKeyReference>, Partial<ForeignKeyReference>],
        excludedTables,
        model,
        sequelize,
      );
    } else {
      RelationFactory.buildOtherRelations(
        foreignReferences,
        excludedTables,
        model,
        uniqueFields,
        sequelize,
      );
    }
  }

  private static buildOtherRelations(
    foreignReferences: Partial<ForeignKeyReference>[],
    excludedTables: string[],
    model: ModelStatic<Model>,
    uniqueFields: string[],
    sequelize: Sequelize,
  ): void {
    foreignReferences.forEach(({ columnName, referencedTableName, referencedColumnName }) => {
      if (excludedTables.includes(referencedTableName)) {
        return;
      }

      const referencedModel = sequelize.model(referencedTableName);

      model.belongsTo(referencedModel, {
        foreignKey: columnName,
        targetKey: referencedColumnName,
      });

      if (uniqueFields.includes(columnName)) {
        referencedModel.hasOne(model, {
          foreignKey: columnName,
          sourceKey: referencedColumnName,
        });
      } else {
        referencedModel.hasMany(model, {
          foreignKey: columnName,
          sourceKey: referencedColumnName,
        });
      }
    });
  }

  private static buildForJunctionTable(
    foreignReferences: [Partial<ForeignKeyReference>, Partial<ForeignKeyReference>],
    excludedTables: string[],
    model: ModelStatic<Model>,
    sequelize: Sequelize,
  ): void {
    const [
      { referencedTableName: tableA, columnName: columnA, referencedColumnName: referencedColumnA },
      { referencedTableName: tableB, columnName: columnB, referencedColumnName: referencedColumnB },
    ] = foreignReferences;

    if (excludedTables.includes(tableA) || excludedTables.includes(tableB)) {
      return;
    }

    const modelA = sequelize.model(tableA);
    const modelB = sequelize.model(tableB);

    modelA.belongsToMany(modelB, {
      through: model.name,
      foreignKey: columnA,
      otherKey: columnB,
    });
    modelB.belongsToMany(modelA, {
      through: model.name,
      foreignKey: columnB,
      otherKey: columnA,
    });
    model.belongsTo(modelA, { foreignKey: columnA, targetKey: referencedColumnA });
    model.belongsTo(modelB, { foreignKey: columnB, targetKey: referencedColumnB });
  }

  private static isJunctionTable(model: ModelStatic<Model>): boolean {
    const modelAttributes = model.getAttributes();
    // remove autogenerated field to keep the belongsToMany behavior
    const modelAttributesDefinition = Object.values(modelAttributes).filter(
      ({ _autoGenerated }) => !_autoGenerated,
    );
    if (modelAttributesDefinition.length !== 2) return false;

    return !modelAttributesDefinition.some(({ primaryKey }) => !primaryKey);
  }
}
